// SPDX-License-Identifier: MIT

pragma solidity 0.8.24;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import { AccessControl } from "@openzeppelin/contracts/access/AccessControl.sol";

import "./libs/Structs.sol";

/**
 * @title Contract VeriricationV2
 * @dev ERC-721 compliant NFT contract that stores wallet verification on chain
 *  WARNING: this is an UNAUDITED smart contract.
 *  NO WARRANTY IS OFFERED OR IMPLIED.
 *  USE AT YOUR OWN RISK.
 */
contract VerificationV0 is ERC721Enumerable, AccessControl {
  /// @dev token id counter
  uint256 private _tokenIdCounter = 1;

  /// @dev role constant. See @openzeppelin/contracts/access/AccessControl.sol
  bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

  /// @dev The base URI for call tokenURI() calls
  string public constant BASE_TOKEN_URI = "https://arweave.net/";

  /// @dev The type name for all NFT's minting out of this contract
  string private _typeName;

  /// @dev maps tokens to their respective verification services
  mapping(uint256 => string) _tokenServices;

  /// @dev maps tokens to their respective verification timestamps
  mapping(uint256 => uint256) _tokenTimestamps;

  /**
   * @dev Creates a new VerificationV0 ERC721 contract.
   * VerificationV0 binds a wallet address to verification service.
   *
   * Token URIs will be autogenerated based on `baseURI` and their token IDs.
   * See {ERC721-tokenURI}.
   */
  constructor(
    string memory name,
    string memory symbol,
    string memory typeName
  ) ERC721(name, symbol) {
    _typeName = typeName;
    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    _grantRole(MINTER_ROLE, msg.sender);
  }

  /**
   * @dev Returns the base URI for all tokens minting. Currently set to arweave.
   *
   */
  function _baseURI() internal view virtual override returns (string memory) {
    return BASE_TOKEN_URI;
  }

  /**
   * @dev Returns the same metadata URI for all owned tokens.
   *
   */
  function tokenURI(uint256 tokenId)
    public
    view
    override
    returns (string memory)
  {
    _requireOwned(tokenId);
    return "https://arweave.net/QhsCULISvUp0C2TgVLaQlBPbn00l7CZoTNGs0z59BzU";
  }

  /**
   * @dev Returns the base URI for all tokens minting. Emits transfer.
   * Must be MINTER_ROLE to call.
   *
   * @param to the address receiving the minted token
   * @param service the name of the verification service, e.g. "Plaid"
   * @param timestamp the UNIX timestamp of when the verification was issued
   */
  function mint(
    address to,
    string memory service,
    uint256 timestamp
  ) public onlyRole(MINTER_ROLE) {
    _safeMint(to, _tokenIdCounter);
    _tokenServices[_tokenIdCounter] = service;
    _tokenTimestamps[_tokenIdCounter] = timestamp;
    _tokenIdCounter++;
  }

  /**
   * @dev Returns the base URI for all tokens minting. Emits transfer.
   * Must be MINTER_ROLE to call.
   *
   * @param tokenId the id of the token to be burned
   */
  function burn(uint256 tokenId) public onlyRole(MINTER_ROLE) {
    _burn(tokenId);
  }

  /**
   * @dev Returns an array of verifications to the given wallet address
   *
   * @param owner the wallet address to query for verifications
   * @return Structs.VerificationData[]
   */
  function verifications(address owner)
    public
    view
    returns (Structs.VerificationData[] memory)
  {
    uint256 bal = balanceOf(owner);
    require(bal > 0, "no verifications");

    Structs.VerificationData[] memory vers = new Structs.VerificationData[](
      bal
    );
    for (uint256 i = 0; i < bal; i++) {
      uint256 tokenId = tokenOfOwnerByIndex(owner, i);
      vers[i] = Structs.VerificationData(
        tokenId,
        _tokenServices[tokenId],
        _tokenTimestamps[tokenId]
      );
    }
    return vers;
  }

  /**
   * @dev Unimplemented. Reverts for all inputs.
   *
   */
  function transferFrom(
    address,
    address,
    uint256
  ) public pure override(ERC721, IERC721) {
    revert("tokens non-transferrable");
  }

  /**
   * @dev Returns the verification service type
   *
   * @return string
   */
  function getTypeName() public view returns (string memory) {
    return _typeName;
  }

  /**
   * @dev Required by superclass. Passes through to superclass.
   *
   * @param interfaceId the interface id
   * @return bool
   */
  function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(ERC721Enumerable, AccessControl)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }
}
